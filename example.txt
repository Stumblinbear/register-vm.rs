// Fuck semicolons
// Use "var" to infer a type from the value provided
// () => { } lambdas
// Any string can have ${} within it to interpolate a value
// [ ] lists
// { } maps
// Capitalized fields or classes are exported/public
// Getters will not exist. While they are convenient, they abstract away computations which can lead to inefficiency.
// I definitely want to include generators.
// 0..9 represents a generator that returns a range of numbers
// import { SomeClass } from 'someModule';
// There can be no code outside of classes or functions.
// Main() is called when executing a script form the command line

// This language is compiled into bytecode. It's relatively simple, but, to increase speed,
// some fuckery is done to primitives such as Int32, Bool, Int64, etc. Instead of using NaN boxing,
// as this is a staticly typed language, the bytecode tells the VM the type of the value it is changing.
// For example: the bytecode to increment an Int32 and an Int64 are different.

// Nullable is not the default. If a parameter, field, or return can be null, it must have a ? after the name.

class ExampleSuperClass {
    construct new() {

    }
}

class ExampleClass : ExampleSuperClass {
    construct new(): super() {
        var i = 0; // i is now of type int
    }
}

struct ExampleStruct {
    test: uInt64
    PublicVariable?: String
}

fn doThing(arg1: String, arg2: Int64 = 0, arg3?: Int32): Bool {
    return true;
}